<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Grid Loch: Infinite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --bg-color: #0f172a;
            /* MODIFIED: Reduced max size from 4.5rem to 3.5rem to prevent desktop scrolling */
            /* Min size set to 2.75rem (~44px) for reliable touch targets */
            --tile-nominal-size: clamp(2.75rem, 12vw, 3.5rem); 
            --buffer-size: 3px; /* Extra space per side for glow/scale (6px total buffer) */
            --slot-size: calc(var(--tile-nominal-size) + 2 * var(--buffer-size));
            --grid-gap: clamp(0.25rem, 2vw, 0.6rem);
            
            /* Calculated height for 3 rows of padded slots + 2 gaps + top/bottom padding (1rem each) */
            --inventory-height: calc(3 * var(--slot-size) + 2 * var(--grid-gap) + 2rem);
        }

        body {
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            display: flex; /* Flex container for header + main content */
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* Only the main scroll area should scroll */
        }

        /* Fixed Header */
        header {
            flex-shrink: 0;
            position: sticky;
            top: 0;
            z-index: 50;
        }

        /* The main scrollable area */
        .main-scroll-area {
            flex: 1;
            overflow-y: auto; /* Enables scrolling below the fixed header */
            display: flex;
            justify-content: center;
            width: 100%;
        }

        .game-layout {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 0.5rem; 
            padding-bottom: 2rem; 
            gap: 0.75rem; /* MODIFIED: Reduced gap to bring controls closer */
            width: 100%;
            max-width: 500px;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--grid-gap);
            padding: 1rem;
            background: #1e293b;
            border-radius: 1rem;
            border: 1px solid #334155;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
            width: fit-content; 
            flex-shrink: 0;
        }

        /* Cell size is now slightly larger (slot-size) to contain the glow */
        .cell {
            width: var(--slot-size);
            height: var(--slot-size);
            background: #334155;
            border-radius: 0.5rem;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.3);
            cursor: pointer;
            box-sizing: border-box;
            padding: var(--buffer-size); /* Add padding buffer */
        }

        .tile {
            /* Tile size is fixed to the nominal size */
            width: var(--tile-nominal-size);
            height: var(--tile-nominal-size);
            background: #f1f5f9;
            color: #0f172a;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: 800;
            cursor: grab;
            position: absolute;
            /* New: Center the element absolutely for correct scaling origin */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); 
            z-index: 10;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: transform 0.1s, opacity 0.1s, border-color 0.1s, background-color 0.3s;
            touch-action: none;
            box-sizing: border-box;
            border: 2px solid transparent;
        }

        .tile:active { cursor: grabbing; }

        .tile.selected {
            border: 3px solid #facc15;
            /* Combine centering transform with scale */
            transform: translate(-50%, -50%) scale(1.1); 
            z-index: 50;
            box-shadow: 0 0 15px rgba(250, 204, 21, 0.5);
        }

        .tile.hard-locked {
            background-color: #475569;
            color: #cbd5e1;
            border: 2px solid #334155;
            cursor: not-allowed;
            box-shadow: none;
        }

        .tile.dragging {
            position: fixed;
            z-index: 9999;
            pointer-events: none;
            opacity: 0.9;
            /* Transform is handled by JS for positioning, only scale remains */
            transform: scale(1.1); 
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
            border-color: #3b82f6;
            touch-action: none; /* ADDED: Explicitly disable touch actions during drag */
        }

        .tile.word-glow {
            background-color: #3b82f6 !important;
            color: white !important;
            box-shadow: 0 0 15px #3b82f6;
            animation: pulse 1.5s infinite;
            border-color: #60a5fa;
        }

        /* NEW: Triumph flash animation */
        .tile.triumph {
            animation: triumph-flash 0.8s 2 ease-in-out; 
        }

        @keyframes triumph-flash {
            0%, 100% { background-color: #3b82f6; box-shadow: 0 0 15px #facc15; }
            50% { background-color: #facc15; box-shadow: 0 0 25px #3b82f6; }
        }

        /* NEW: Error Shake for valid but incorrect words */
        .tile.word-error {
            animation: error-shake 0.5s ease-in-out;
        }

        @keyframes error-shake {
            0%, 100% { transform: translate(-50%, -50%); border-color: transparent; }
            15% { transform: translate(calc(-50% - 4px), -50%); border-color: #ef4444; box-shadow: 0 0 10px #ef4444; }
            30% { transform: translate(calc(-50% + 4px), -50%); border-color: #ef4444; box-shadow: 0 0 10px #ef4444; }
            45% { transform: translate(calc(-50% - 4px), -50%); border-color: #ef4444; box-shadow: 0 0 10px #ef4444; }
            60% { transform: translate(calc(-50% + 4px), -50%); border-color: #ef4444; box-shadow: 0 0 10px #ef4444; }
            75% { transform: translate(calc(-50% - 4px), -50%); border-color: #ef4444; box-shadow: 0 0 10px #ef4444; }
        }

        .highlight {
            background-color: rgba(59, 130, 246, 0.3);
            box-shadow: 0 0 0 2px #3b82f6;
        }

        .inventory-wrapper {
            width: 100%;
            max-width: 32rem;
            flex-shrink: 0;
            padding: 0 1rem;
        }

        /* Fixed height based on CSS variables */
        .inventory-container {
            width: 100%;
            height: var(--inventory-height); /* Set to 3 rows of padded slots */
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid #334155;
            border-radius: 0.75rem;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .inventory-grid {
            display: flex;
            flex-wrap: wrap;
            /* FIX: Justify to the start/left */
            justify-content: flex-start;
            /* FIX: Align content to the start/top */
            align-content: flex-start; 
            gap: 0.5rem;
            height: 100%;
            overflow-y: hidden; 
        }

        /* Inventory slot size is now based on slot-size variable */
        .inventory-slot {
            width: var(--slot-size);
            height: var(--slot-size);
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0.5rem;
            position: relative;
            flex-shrink: 0;
            box-sizing: border-box;
            padding: var(--buffer-size); /* Add padding buffer */
        }
        
        .loader {
            width: 20px;
            height: 20px;
            border: 3px solid #FFF;
            border-bottom-color: transparent;
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }

        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .nessie-fallback-icon {
            width: 100%;
            height: 100%;
            padding: 5px;
            stroke: #38bdf8;
            stroke-width: 3;
            fill: none;
        }
        
        /* Control Bar Style (Now part of scrollable content) */
        #control-bar {
            width: 100%;
            max-width: 32rem;
            padding: 1rem;
            background-color: #1e293b; 
            border-radius: 0.75rem;
            /* MODIFIED: Reduced margin-top to pull closer to inventory */
            margin-top: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-around;
            align-items: center;
        }
        
        /* FIX: Enforce stable height and use dynamic font sizing */
        #status-msg {
            /* Text centering and wrapping */
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            word-break: break-word;
            white-space: normal;

            /* Font size that shrinks from 0.75rem down to 0.6rem if needed */
            font-size: clamp(0.6rem, 2vw, 0.75rem); 
            line-height: 1.25;

            /* Fixed dimensions (increased height) to prevent layout shifts */
            height: 45px; /* Increased from 30px to 45px for 3 lines */
            max-height: 45px;
            overflow: hidden; 
        }

        /* Scorecard styling for the solved grid */
        .score-grid {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 0.5rem;
            max-width: 10rem;
            margin: 1rem auto;
        }
        .score-cell {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }
        .score-cell.locked {
            background-color: #020617; /* Black (Slate 950) for Locked/Hints/Auto */
            border: 1px solid #334155;
        }
        .score-cell.correct {
            background-color: #94a3b8; /* Gray (Slate 400) for Standard Solve (Failed First Try) */
        }
        .score-cell.semi-perfect {
            background-color: #3b82f6; /* Blue for One-Way First Try */
        }
        .score-cell.perfect {
            background-color: #facc15; /* Yellow for Perfect First Try (Both Ways) */
            box-shadow: 0 0 5px rgba(250, 204, 21, 0.5);
        }

        /* Modal styling update to ensure interactions work */
        #modal {
            pointer-events: auto !important;
        }

        /* Score Key Styling */
        .score-key {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
            margin-top: 0.75rem;
            font-size: 0.7rem;
            color: #94a3b8;
        }
        .score-key-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .key-dot {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }
        
        /* Overlay Animations */
        .fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        /* Disabled button state for Daily Reset */
        .btn-disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
    </style>

    <!-- Generic Placeholder Favicon -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='90' font-size='90'%3EG%3C/text%3E%3C/svg%3E">
</head>
<body class="text-slate-100">

    <!-- STARTUP OVERLAY -->
    <div id="startup-overlay" class="fixed inset-0 bg-slate-900 z-[200] flex flex-col items-center justify-center p-4 transition-opacity duration-500">
        <div class="text-center mb-10">
            <div class="flex items-center justify-center mb-4 text-blue-500">
                <!-- Simple Grid Icon (Updated to 4x4) -->
                <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="2" y="2" width="20" height="20" rx="2"/>
                    <path d="M2 7h20M2 12h20M2 17h20M7 2v20M12 2v20M17 2v20"/>
                </svg>
            </div>
            <h1 class="text-5xl font-black text-white tracking-widest drop-shadow-2xl mb-2">GRID LOCH</h1>
            <p class="text-slate-400 text-sm tracking-wide">INFINITE WORD PUZZLES</p>
        </div>

        <!-- DAILY BUTTON CONTAINER -->
        <div id="daily-btn-container" class="w-full max-w-xs mb-8">
            <button id="btn-daily-start" onclick="startGame('daily')" class="w-full bg-gradient-to-r from-yellow-500 to-yellow-600 hover:from-yellow-400 hover:to-yellow-500 text-white font-bold py-4 px-8 rounded-xl shadow-lg transform transition-all hover:scale-105 active:scale-95 flex items-center justify-center gap-3 group">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="group-hover:rotate-12 transition-transform"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                <span class="text-center">DAILY CHALLENGE</span>
            </button>
        </div>

        <div class="flex items-center w-full max-w-xs mb-6 opacity-60">
            <div class="h-px bg-slate-600 flex-1"></div>
            <span class="px-4 text-slate-400 text-xs font-bold uppercase tracking-widest">Practice Mode</span>
            <div class="h-px bg-slate-600 flex-1"></div>
        </div>

        <div class="flex gap-3 w-full max-w-xs">
            <button onclick="startGame('easy')" class="flex-1 bg-slate-800 hover:bg-slate-700 border border-slate-700 hover:border-blue-500 text-blue-400 font-bold py-3 rounded-lg transition-all active:scale-95">
                Easy
            </button>
            <button onclick="startGame('medium')" class="flex-1 bg-slate-800 hover:bg-slate-700 border border-slate-700 hover:border-blue-500 text-blue-400 font-bold py-3 rounded-lg transition-all active:scale-95">
                Medium
            </button>
            <button onclick="startGame('hard')" class="flex-1 bg-slate-800 hover:bg-slate-700 border border-slate-700 hover:border-blue-500 text-blue-400 font-bold py-3 rounded-lg transition-all active:scale-95">
                Hard
            </button>
        </div>
    </div>
    <!-- END STARTUP OVERLAY -->

    <header class="w-full p-4 flex justify-between items-center bg-slate-900 border-b border-slate-800">
        <div class="flex items-start">
            <div class="flex flex-col">
                <div class="flex items-center text-xl font-black tracking-wider text-blue-400">
                    <span>GRID LOCH</span>
                </div>
                <!-- Timer moved to replace the subtitle -->
                <div id="timerDisplay" class="text-xs font-mono text-slate-500">00:00</div>
            </div>
        </div>
        
        <!-- Adjusted button group -->
        <div class="flex items-center gap-2 w-1/2 sm:w-auto justify-end">
            <button id="menuBtn" class="bg-slate-800 text-sm text-blue-400 px-3 py-2 rounded border border-slate-700 hover:border-blue-500 transition-colors font-bold">
                MENU
            </button>
            <button id="newGameBtn" class="p-2 bg-blue-600 rounded hover:bg-blue-500 text-white shadow-lg active:transform active:scale-95 transition-all flex-shrink-0">
                <i data-lucide="rotate-ccw" class="w-5 h-5"></i>
            </button>
        </div>
    </header>

    <main class="main-scroll-area">
        <div class="game-layout">
            
            <div id="game-grid" class="grid-container"></div>
            
            <div class="inventory-wrapper">
                <div class="inventory-container shadow-xl">
                    <!-- Removed title to save space -->
                    <div id="inventory" class="inventory-grid"></div>
                </div>
            </div>

            <!-- Hint/Solve controls moved from fixed footer into the scrollable content area -->
            <div id="control-bar" class="w-full px-4">
                <button id="hintBtn" class="flex flex-col items-center gap-1 text-slate-400 hover:text-yellow-400 active:text-yellow-500 transition-colors">
                    <i data-lucide="lightbulb" class="w-6 h-6"></i>
                    <span class="text-[10px] font-bold uppercase">Hint</span>
                </button>
                <div id="status-msg" class="text-center font-bold text-blue-500 animate-pulse w-32">
                    SELECT & PLACE
                </div>
                <button id="solveBtn" class="flex flex-col items-center gap-1 text-slate-400 hover:text-green-400 active:text-green-500 transition-colors">
                    <i data-lucide="check-circle" class="w-6 h-6"></i>
                    <span class="text-[10px] font-bold uppercase">Solve</span>
                </button>
            </div>
            <!-- End of control bar -->
        </div>
    </main>

    <div id="modal" class="fixed inset-0 bg-black/90 flex items-center justify-center z-[300] hidden opacity-0 transition-opacity duration-300 backdrop-blur-sm">
        <div class="bg-slate-800 p-8 rounded-2xl border-2 border-blue-500 text-center shadow-2xl transform scale-90 transition-transform duration-300 max-w-sm w-full mx-4" id="modal-content">
            
            <!-- NEW: Score Display -->
            <div class="flex flex-col items-center mb-4">
                <div id="final-score" class="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-b from-yellow-300 to-yellow-600 drop-shadow-sm">0</div>
                <div class="text-xs font-bold tracking-widest text-slate-500 uppercase mt-1">Total Score</div>
            </div>

            <!-- Replaced Icon Container with Score Grid Container -->
            <div id="modal-score-container" class="score-grid mx-auto"></div>
            
            <!-- NEW: Legend/Key -->
            <div id="score-legend" class="score-key mb-6"></div>
            
            <h2 class="text-2xl font-black text-white mb-2">SOLVED!</h2>
            <p class="text-slate-400 mb-6 text-sm">You've mastered this grid.</p>
            
            <div class="flex flex-col gap-2 w-full">
                <button id="playAgainBtn" class="px-6 py-3 bg-blue-600 hover:bg-blue-500 active:bg-blue-700 text-white rounded-lg font-bold shadow-lg w-full transition-colors">
                    Next Puzzle
                </button>
                <button id="modalMenuBtn" class="px-6 py-3 bg-slate-700 hover:bg-slate-600 text-slate-200 rounded-lg font-bold shadow-lg w-full transition-colors">
                    Return to Menu
                </button>
            </div>
        </div>
    </div>

<script>
    // --- Expanded Dictionary (~2000 Common Words) - Sanitized ---
    const COMMON_WORDS = [
        "ABLE","ACID","ACME","ACRE","ACTS","ADDS","AGES","AIDE","AIDS","AIMS","AIRS","ALAS","ALLY","ALMS","ALSO",
        "ALTO","AMEN","AMID","AMPS","ANEW","ANTE","ANTI","ANTS","APES","APEX","APPS","AQUA","ARCH",
        "AREA","ARID","ARMS","ARMY","ARTS","ASHY","ASKS","ATOM","AUNT","AURA","AUTO","AVID","AWAY","AXES","AXIS",
        "BABE","BABY","BACK","BADS","BAGS","BAIL","BAIT","BAKE","BALD","BALE","BALL","BALM","BAND","BANG","BANK",
        "BARK","BARN","BARS","BASE","BASH","BASS","BATH","BATS","BAYS","BEAK","BEAM","BEAN","BEAR","BEAT","BEAU",
        "BECK","BEDS","BEEF","BEER","BEES","BEGS","BELL","BELT","BEND","BENT","BERG","BEST","BETS","BIAS","BIDS",
        "BIKE","BILE","BILL","BINS","BIND","BIOS","BIRD","BITE","BITS","BLAB","BLAH","BLAM","BLAT","BLED",
        "BLEW","BLIP","BLOB","BLOG","BLOT","BLOW","BLUE","BLUR","BOAR","BOAT","BOBS","BOCK","BODE","BODY","BOGS",
        "BOIL","BOLD","BOLL","BOLT","BOMB","BOND","BONE","BONG","BONK","BOOK","BOOM","BOON","BOOT","BORA","BORE",
        "BORN","BOSS","BOTH","BOTS","BOUT","BOWL","BOWS","BOYS","BRAG","BRAN","BRAS","BRAT","BRAY","BRED","BREW",
        "BRIM","BROS","BROW","BUCK","BUDS","BUFF","BUGS","BULB","BULK","BULL","BUMP","BUND","BUNK","BUNS",
        "BUOY","BURD","BURG","BURL","BURN","BURP","BURR","BURY","BUSH","BUSK","BUST","BUSY","BUTS","BUTT","BUYS",
        "BUZZ","BYES","BYTE","CABS","CAFE","CAGE","CAKE","CALF","CALL","CALM","CAME","CAMP","CAMS","CANE","CANS",
        "CANT","CAPE","CAPS","CARB","CARD","CARE","CARS","CART","CASE","CASH","CASK","CAST","CATS","CAVE","CEES",
        "CELL","CENT","CHAD","CHAP","CHAR","CHAT","CHEF","CHEW","CHIC","CHID","CHIN","CHIP","CHOP","CHOW","CHUG",
        "CHUM","CITE","CITY","CLAD","CLAM","CLAN","CLAP","CLAW","CLAY","CLEF","CLIP","CLOG","CLOT","CLUB","CLUE",
        "COAL","COAT","COAX","COBS","COCO","CODE","COGS","COIL","COIN","COKE","COLD","COLT","COMA","COMB",
        "COME","CONE","CONS","COOK","COOL","COOP","COPS","COPY","CORD","CORE","CORK","CORN","COST","COTS",
        "COUP","COVE","COWL","COWS","CRAB","CRAG","CRAM","CRAW","CREW","CRIB","CROP","CROW","CRUX",
        "CUBE","CUBS","CUFF","CULL","CULT","CUPS","CURB","CURD","CURE","CURL","CURT","CUSP","CUTE","CUTS","CYST",
        "DABS","DADS","DAFT","DAIS","DALE","DAME","DAMN","DAMP","DAMS","DANG","DANK","DARE","DARK","DARN","DART",
        "DASH","DATA","DATE","DAWN","DAYS","DAZE","DEAD","DEAF","DEAL","DEAN","DEAR","DEBT","DECK","DEED","DEEM",
        "DEEP","DEER","DEFT","DEFY","DELI","DELL","DEMO","DENS","DENT","DENY","DESK","DEWS","DIAL","DICE","DIED",
        "DIES","DIET","DIGS","DIKE","DIME","DIMS","DINE","DING","DINS","DIPS","DIRE","DIRT","DISC","DISH","DISK",
        "DIVE","DOCK","DOCS","DOER","DOES","DOGS","DOLE","DOLL","DOME","DONE","DOGS","DONS","DOOM","DOOR",
        "DOPE","DOSE","DOTS","DOUG","DOUR","DOVE","DOWN","DOZE","DRAB","DRAG","DRAM","DRAW","DREW","DRIP",
        "DROP","DRUB","DRUG","DRUM","DUAL","DUCK","DUCT","DUDE","DUDS","DUEL","DUES","DUET","DUFF","DUKE","DULL",
        "DULY","DUMB","DUMP","DUNE","DUNG","DUNK","DUOS","DUPE","DUSK","DUST","DUTY","DYED","DYES","DYKE","EACH",
        "EARL","EARN","EARS","EASE","EAST","EASY","EATS","EBBS","ECHO","ECRU","EDGE","EDIT","EELS","EGGS","EGOS",
        "ELLS","EMIT","ENDS","ENVY","EONS","EPIC","ERAS","ERGO","ERGS","EROS",
        "ETCH","EVEN","EVER","EVIL","EWES","EXAM","EXES","EXIT","EYED","EYES","FACE","FACT","FADE",
        "FADS","FAIL","FAIR","FAKE","FALL","FAME","FANG","FANS","FARE","FARM","FAST","FATE","FATS","FAUN",
        "FAWN","FAZE","FEAR","FEAT","FEDS","FEED","FEEL","FEES","FEET","FELL","FELT","FEND","FERN","FEST","FETE",
        "FEUD","FIAT","FIBS","FIGS","FILE","FILL","FILM","FIND","FINE","FINK","FINS","FIRE","FIRM",
        "FIRS","FISH","FIST","FITS","FIVE","FIZZ","FLAG","FLAK","FLAN","FLAP","FLAT","FLAW","FLAX","FLAY","FLEA",
        "FLED","FLEE","FLEW","FLEX","FLIP","FLIT","FLOG","FLOP","FLOW","FLUE","FLUX","FOAL","FOAM","FOCI","FOGS",
        "FOIL","FOLD","FOLK","FOND","FONT","FOOD","FOOL","FOOT","FORD","FORE","FORK","FORM","FORT","FOUL","FOUR",
        "FOWL","FOXY","FRAG","FRAY","FREE","FRET","FROG","FROM","FUEL","FULL","FUME","FUND","FUNK","FURS","FURY",
        "FUSE","FUSS","GABS","GADS","GAGA","GAGE","GAGS","GAIN","GAIT","GALA","GALE","GALL","GALS","GAME","GAMS",
        "GANG","GAPE","GAPS","GARB","GASH","GASP","GATE","GATS","GAVE","GAWK","GAYS","GAZE","GEAR","GEEK","GELS",
        "GEMS","GENE","GENS","GENT","GERM","GETS","GIBE","GIFT","GIGS","GILD","GILL","GILT","GINS","GIRD","GIRL",
        "GIST","GIVE","GLAD","GLAM","GLEE","GLEN","GLIB","GLOP","GLOW","GLUE","GLUM","GLUT","GNAT","GNAW","GOAD",
        "GOAL","GOAS","GOAT","GOBS","GODS","GOER","GOES","GOLD","GOLF","GONE","GONG","GOOD","GOOF","GOON","GORE",
        "GORY","GOSH","GOTH","GOUT","GOWN","GRAB","GRAD","GRAM","GRAN","GRAY","GREW","GREY","GRID","GRIM","GRIN",
        "GRIP","GRIT","GROW","GRUB","GULF","GULL","GULP","GUMS","GUNS","GURU","GUSH","GUTS","GUYS","GYMS","GYRO",
        "HACK","HAGS","HAIL","HAIR","HALE","HALF","HALL","HALO","HALT","HAMS","HAND","HANG","HANK","HARD","HARE",
        "HARK","HARM","HARP","HART","HASH","HATE","HATS","HAUL","HAVE","HAWK","HAZE","HAZY","HEAD","HEAL","HEAP",
        "HEAR","HEAT","HECK","HEED","HEEL","HEFT","HEIR","HELD","HELL","HELM","HELP","HEMS","HENS","HERB","HERD",
        "HERE","HERO","HERS","HEWN","HICK","HIDE","HIGH","HIKE","HILL","HILT","HIND","HINT","HIPS","HIRE","HISS",
        "HITS","HIVE","HOAX","HOBS","HOCK","HOES","HOGS","HOLD","HOLE","HOLM","HOLY","HOME","HONE","HONK","HOOD",
        "HOOF","HOOK","HOOP","HOOT","HOPE","HOPS","HORN","HOSE","HOST","HOTS","HOUR","HOVE","HOWL","HUBS","HUFF",
        "HUGE","HUGS","HULA","HULK","HULL","HUMS","HUNG","HUNK","HUNT","HURL","HURT","HUSH","HUSK","HUTS","HYMN",
        "HYPE","ICED","ICES","ICON","IDEA","IDLE","IDOL","IDYL","IGLU","ILLS","IMPS","INCH","INFO","INKS","INKY",
        "INNS","INTO","IONS","IOTA","IRIS","IRON","ISLE","ISMS","ITCH","ITEM","JABS","JACK","JADE","JAGS","JAIL",
        "JAMB","JAMS","JARS","JAWS","JAYS","JAZZ","JEAN","JEEB","JEEP","JEER","JELL","JERK","JEST","JETS","JEWS",
        "JIBE","JIBS","JIGS","JILT","JINX","JIVE","JOBS","JOCK","JOGS","JOHN","JOIN","JOKE","JOLT","JOWL","JOYS",
        "JUDO","JUGS","JUMP","JUNK","JURY","JUST","JUTE","JUTS","KALE","KAYO","KEEL","KEEN","KEEP","KEGS","KELP",
        "KENO","KEPT","KEYS","KICK","KIDS","KILL","KILN","KILO","KILT","KIND","KING","KINK","KISS","KITE","KITS",
        "KIWI","KNEE","KNEW","KNIT","KNOB","KNOT","KNOW","KOAN","KOOK","LABS","LACE","LACK","LACY","LADS","LADY",
        "LAGS","LAID","LAIN","LAIR","LAKE","LAMB","LAME","LAMP","LAMS","LAND","LANE","LANK","LAPS","LARD","LARK",
        "LASH","LASS","LAST","LATE","LATH","LAUD","LAVA","LAWN","LAWS","LAYS","LAZE","LAZY","LEAD","LEAF","LEAK",
        "LEAN","LEAP","LEAR","LEAS","LEFT","LEGS","LEIS","LEND","LENS","LENT","LESS","LEST","LETS","LEVY","LEWD",
        "LIAR","LICE","LICK","LIDS","LIED","LIEN","LIES","LIEU","LIFE","LIFT","LIKE","LILT","LILY","LIMB","LIME",
        "LINE","LINK","LINT","LION","LIPS","LISP","LIST","LITE","LIVE","LOAD","LOAF","LOAM","LOAN",
        "LOBE","LOBS","LOCK","LOCO","LODE","LOFT","LOGO","LOGS","LOIN","LONE","LONG","LOOK","LOOM","LOON","LOOP",
        "LOOS","LOOT","LOPE","LOPS","LORD","LORE","LOSE","LOSS","LOST","LOTS","LOUD","LOUT","LOVE","LOWS","LUAU",
        "LUGE","LUGS","LULL","LUMP","LUNG","LURE","LURK","LUSH","LUST","LUTE","LUXE","LYRE","MACE",
        "MADE","MAGS","MAID","MAIL","MAIM","MAIN","MAKE","MALE","MALL","MALT","MAMA","MANE","MANY","MAPS","MARE",
        "MARK","MARS","MART","MASH","MASK","MASS","MAST","MATE","MATH","MATS","MAUL","MAWS","MAXI","MAZE","MEAD",
        "MEAL","MEAN","MEAT","MEED","MEEK","MEET","MEGA","MELD","MELT","MEMO","MEND","MENU","MEOW","MERE",
        "MESA","MESH","MESS","META","MICE","MILD","MILE","MILK","MILL","MIME","MIND","MINE","MINI","MINK",
        "MINT","MIRE","MISS","MIST","MITE","MITT","MOAN","MOAT","MOBS","MOCK","MODE","MOJO","MOLD","MOLE","MOLT",
        "MOMS","MONK","MONO","MOOD","MOON","MOOR","MOOS","MOOT","MOPE","MOPS","MORE","MORN","MOSS","MOST",
        "MOTH","MOVE","MOWS","MUCH","MUCK","MUFF","MUGS","MULE","MULL","MUMS","MUSH","MUSK","MUST","MUTE",
        "MUTT","MYTH","NABS","NAGS","NAIL","NAME","NAPS","NARK","NAVY","NEAR","NEAT","NECK","NEED","NEON",
        "NERD","NEST","NETS","NEWS","NEWT","NEXT","NIBS","NICE","NICK","NIGH","NILE","NINE","NIPS","NODE","NODS",
        "NOEL","NOES","NOIR","NOIS","NOMA","NOMS","NONE","NOOK","NOON","NOPE","NORM","NOSE","NOSY","NOTE","NOUN",
        "NOVA","NUDE","NUKE","NULL","NUMB","NUNS","NUTS","OAFS","OAKS","OARS","OATH","OATS","OBEY","OBOE","ODDS",
        "ODOR","OGRE","OILS","OILY","OINK","OKAY","OKRA","OLDS","OLIO","OMEN","OMIT","ONCE","ONES","ONLY","ONTO",
        "ONUS","ONYX","OOZE","OPEN","OPUS","ORAL","ORBS","ORGY","ORCA","ORES","ORGY","OUNC","OURS","OUST",
        "OUTS","OVAL","OVEN","OVER","OWED","OWES","OWLS","OWNS","OXEN","PACE","PACK","PACT","PADS","PAGE","PAID",
        "PAIL","PAIN","PAIR","PALE","PALM","PALS","PANE","PANG","PANS","PANT","PAPA","PARE","PARK","PART","PASS",
        "PAST","PATE","PATH","PATS","PAVE","PAWN","PAWS","PAYS","PEAK","PEAL","PEAR","PEAS","PEAT","PECK","PEEK",
        "PEEL","PEEP","PEER","PEGS","PELT","PENS","PENT","PEON","PEPS","PERK","PERM","PEST","PETS","PEWS","PHAT",
        "PHEW","PICK","PIED","PIER","PIES","PIGS","PIKE","PILE","PILL","PINE","PING","PINK","PINS","PINT",
        "PIPE","PIPS","PITY","PLAN","PLAY","PLEA","PLOD","PLOP","PLOT","PLOW","PLOY","PLUG","PLUM","PLUS",
        "POCK","PODS","POEM","POET","POKE","POLE","POLL","POLO","POND","PONS","PONY","POOH","POOL",
        "POPE","POPS","PORE","PORK","PORT","POSE","POSH","POST","POSY","POTS","POUR","POUT","PRAM",
        "PRAY","PREP","PREY","PRIM","PROD","PROF","PROM","PROP","PROS","PROW","PUBS","PULL","PULP","PUMA",
        "PUMP","PUNK","PUNS","PUNT","PUNY","PUPS","PURE","PURL","PURR","PUSH","PUTS","PUTT","PYRE","QUAD","QUAY",
        "QUIP","QUIT","QUIZ","RACE","RACK","RACY","RADS","RAFT","RAGE","RAGS","RAID","RAIL","RAIN","RAKE","RAMP",
        "RAMS","RANCH","RAND","RANG","RANK","RANT","RAPE","RAPS","RARE","RASH","RASP","RATE","RATS","RAVE","RAWN",
        "RAWS","RAYS","RAZE","RAZZ","READ","REAL","REAM","REAP","REAR","RECK","REDO","REDS","REED","REEF","REEK",
        "REEL","REIN","RELY","REND","RENT","REPS","REST","RIBS","RICE","RICH","RICK","RIDE","RIDS","RIFE","RIFF",
        "RIFT","RIGS","RILE","RIMS","RIND","RING","RINK","RIOT","RIPE","RIPS","RISE","RISK","RITE","RITS","RITZ",
        "ROAD","ROAM","ROAN","ROAR","ROBE","ROBS","ROCK","RODE","RODS","ROES","ROIL","ROLE","ROLL",
        "ROMP","ROOF","ROOK","ROOM","ROOT","ROPE","ROSE","ROSY","ROTS","ROUT","ROVE","ROWS","RUBS","RUBY","RUDE",
        "RUE","RUGS","RUIN","RULE","RUNS","RUNT","RUSE","RUSH","RUSK","RUST","RUTS",
        "SACK","SACS","SAFE","SAGA","SAGE","SAID","SAIL","SAKE","SALE","SALT","SAME","SAND","SANE","SANG","SANK",
        "SANS","SAPS","SASH","SASS","SATE","SAVE","SAWS","SAYS","SCAB","SCAM","SCAN","SCAR","SCAT","SEA","SEAL",
        "SEAM","SEAR","SEAS","SEAT","SECT","SEED","SEEK","SEEM","SEEN","SEEP","SEES","SELF","SELL",
        "SEMI","SEND","SENT","SERF","SETS","SEWN","SEWS","SEXY","SHAD","SHAG","SHAM","SHED","SHES","SHIM","SHIN",
        "SHIP","SHIV","SHOE","SHOO","SHOP","SHOT","SHOW","SHUN","SHUT","SICK","SIDE","SIFT","SIGH","SIGN","SILK",
        "SILL","SILO","SILT","SINE","SING","SINK","SINS","SIPS","SIRE","SIRS","SITE","SITS","SIZE","SKEW","SKID",
        "SKIM","SKIN","SKIP","SKIS","SKIT","SLAB","SLAM","SLAP","SLAT","SLAY","SLED","SLEW","SLID","SLIM","SLIP",
        "SLIT","SLOB","SLOG","SLOP","SLOT","SLOW","SLUE","SLUG","SLUM","SLUR","SNAG","SNAP",
        "SNIP","SNOB","SNOG","SNOT","SNOW","SNUB","SNUG","SOAK","SOAP","SOAR","SOBS","SOCK","SODA","SODS","SOFA",
        "SOFT","SOIL","SOLD","SOLE","SOLO","SOMA","SOME","SONG","SONS","SOON","SOOT","SOPS","SORE","SORT","SOSO",
        "SOTS","SOUL","SOUP","SOUR","SOWN","SOWS","CROW","SPAM","SPAN","SPAR","SPAS","SPAT","SPAY","SPEC","SPED",
        "SPEW","SPIN","SPIT","SPOT","SPRY","SPUD","SPUN","SPUR","STAB","STAG","STAR","STAT","STAY","STEM","STEP",
        "STEW","STIR","STOP","STOW","STUB","STUD","STUN","SUCH","DUCK","SUDS","SUED","SUES","SUIT","SULK","SUMO",
        "SUMS","SUNG","SUNK","SUNS","SUPS","SURE","SURF","SWAB","SWAG","SWAM","SWAN","SWAP","SWAT","SWAY","SWIG",
        "SWIM","SWUM","SYNC","TABS","TACK","TACO","TACT","TADS","TAGS","TAIL","TAKE","TALE","TALK","TALL",
        "TAME","TAMP","TAMS","TANG","TANK","TANS","TAPE","TAPS","TARE","TARP","TART","TASK","TAUT","TAX","TAXI",
        "TEAK","TEAM","TEAR","TEAS","TEAT","TECH","TEED","TEEM","TEEN","TEES","TELL","TEND","TENT","TERM",
        "TEST","TEXT","THAN","THAT","THAW","THEE","THEM","THEN","THEW","THEY","THIN","THIS","THOU","THRO","THRU",
        "THUD","THUG","THUS","TICK","TIDE","TIDY","TIED","TIER","TIES","TIFF","TILE","TILL","TILT","TIME","TINE",
        "TING","TINS","TINT","TINY","TIPS","TIRE","TOAD","TOED","TOES","TOFU","TOGA","TOGS","TOIL","TOLD","TOLL",
        "TOMB","TOME","TONE","TONG","TONS","TOOK","TOOL","TOOT","TOPS","TORE","TORN","TORT","TOSS","TOTE","TOTS",
        "TOUR","TOUT","TOWN","TOWS","TOYS","TRAM","TRAP","TRAY","TREE","TREK","TRIM","TRIO","TRIP","TROD","TROT",
        "TRUE","TUBA","TUBE","TUBS","TUCK","TUFT","TUGS","TUNA","TUNE","TUNS","TURF","TURN","TUSK",
        "TUTU","TWAS","TWIG","TWIN","TWIT","TWOS","TYKE","TYPE","TYPO","UGLY","ULNA","UNDO",
        "UNIT","UNTO","UPON","URGE","URNS","USED","USER","USES","VAIL","VAIN","VALE","VAMP","VANE","VANS","VARY",
        "VASE","VAST","VATS","VEAL","VEER","VEIL","VEIN","VEND","VENT","VERB","VERY","VEST","VETS","VIAL","VIBE",
        "VICE","VIEW","VIGS","VILE","VINE","VINO","VIOL","VISA","VISE","VITA","VOID","VOLT","VOTE","VOWS",
        "WACK","WADE","WADS","WAFT","WAGE","WAGS","WAIF","WAIL","WAIST","WAIT","WAKE","WALK","WALL","WAND",
        "WANE","WANT","WARD","WARE","WARM","WARN","WARP","WARS","WART","WARY","WASH","WASP","WAST","WATT",
        "WAVE","WAVY","WAX","WAYS","WEAK","WEAL","WEAN","WEAR","WEBS","WEDS","WEED","WEEK","WEEP","WELD","WELL",
        "WELT","WENT","WEPT","WERE","WEST","WETS","WHAM","WHAT","WHEE","WHEN","WHET","WHOW","WHEY","WHIM","WHIN",
        "WHIP","WHIT","WHIZ","WHOA","WHOM","WICK","WIDE","WIFE","WIGS","WILD","WILE","WILL","WILT","WILY","WIND",
        "WINE","WING","WINK","WINO","WINS","WIPE","WIRE","WIRY","WISE","WISH","WISP","WITH","WITS","WIVES","WOES",
        "WOKE","WOLF","WOMB","WONT","WOOD","WOOF","WOOL","WOOS","WORD","WORE","WORK","WORM","WORN","WOVE","WOWS",
        "WRAP","WREN","WRIT","WRONG","WROTE","YAKS","YAMS","YANK","YARD","YARN","YAWL","YAWN","YEAH","YEAR","YEAS",
        "YELL","YELP","YETI","YEWS","YOGA","YOKE","YOLK","YOND","YORE","YOUR","YOWL","YUCK","YUKS","YULE","ZANY",
        "ZAPS","ZEAL","ZERO","ZEST","ZINC","ZING","ZITS","ZONE","ZOOM","ZOOS"
    ];

    // Pre-process dictionary for speed
    const WORD_SET = new Set(COMMON_WORDS);
    const PREFIX_SET = new Set();
    COMMON_WORDS.forEach(w => {
        PREFIX_SET.add(w.substring(0, 1));
        PREFIX_SET.add(w.substring(0, 2));
        PREFIX_SET.add(w.substring(0, 3));
        PREFIX_SET.add(w);
    });

    // --- Sarcastic Messages ---
    const SARCASTIC_MESSAGES = {
        HINT: [
            "Need a hand, champ? It's right there.",
            "That's one less letter you have to worry about.",
            "We're basically co-solving this puzzle now.",
            "Ah, the 'strategic assistance' button.",
            "Don't worry, I won't tell anyone."
        ],
        HINT_FAIL: [
            "Did you really need a hint for that many letters?",
            "Look, I'm just the software, but maybe try thinking?",
            "Using this many hints is starting to cost us money.",
            "At this rate, the 'Solve' button will be faster.",
            "I'm running out of easy letters to give you."
        ],
        SOLVE: [
            "Phew! That was a close one, but *I* nailed it.",
            "Great job! (Manual override activated.)",
            "Solved. Effort: Minimum. Power: Optimal.",
            "Don't strain yourself. I'll handle the hard stuff.",
            "You earned that win... by clicking the button."
        ]
    };

    // --- Global Variables & State ---
    let currentMode = 'medium';
    let isGameWon = false; // Tracks if current session is complete
    let finalScore = 0;    // Tracks score of current completed session
    
    // Storage Keys
    const STORAGE_KEY = 'gridLochData';

    // Game State Variables
    let currentSolution = [];
    let gridState = Array(16).fill(null);
    let inventory = [];
    let lockedIndices = new Set();
    
    let failedRows = new Set();
    let failedCols = new Set();
    let processedPatterns = new Set();

    let selectedState = null;
    let usedWordsInPuzzle = new Set();
    let hintsUsed = 0; 
    let isAutoSolving = false; 
    let solvedPatterns = new Set();
    let errorPatterns = new Set();
    
    // Timer Variables
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    let startTime = 0;
    let timerInterval = null;
    let elapsedTime = 0;

    // --- Persistence Logic ---

    function getStoredData() {
        try {
            return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {};
        } catch(e) {
            return {};
        }
    }

    function saveGameState() {
        const data = getStoredData();
        
        // Save current state for current mode
        data[currentMode] = {
            gridState: gridState,
            inventory: inventory,
            lockedIndices: [...lockedIndices],
            failedRows: [...failedRows],
            failedCols: [...failedCols],
            processedPatterns: [...processedPatterns],
            solvedPatterns: [...solvedPatterns],
            errorPatterns: [...errorPatterns],
            currentSolution: currentSolution,
            elapsedTime: elapsedTime,
            hintsUsed: hintsUsed,
            seed: currentMode === 'daily' ? getDailySeed() : null, // Store seed for validation
            isComplete: isGameWon, // Use global flag
            finalScore: finalScore // Use global flag
        };
        
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    }

    function clearModeState(mode) {
        const data = getStoredData();
        delete data[mode];
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    }

    // Check daily validity
    function checkDailyReset() {
        const data = getStoredData();
        const todaySeed = getDailySeed();
        
        if (data.daily) {
            if (data.daily.seed !== todaySeed) {
                // New day, clear old daily data
                delete data.daily;
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            }
        }
        return data;
    }

    // --- Menu UI Logic ---
    
    function updateMenuUI() {
        const data = checkDailyReset();
        const startBtn = document.getElementById('btn-daily-start');
        const btnTextSpan = startBtn.querySelector('span');
        const btnIcon = startBtn.querySelector('svg');

        // Check if daily is complete
        if (data.daily && data.daily.isComplete) {
            // --- STATE: COMPLETED ---
            
            // Remove active styling
            startBtn.classList.remove('from-yellow-500', 'to-yellow-600', 'hover:from-yellow-400', 'hover:to-yellow-500', 'hover:scale-105', 'active:scale-95');
            
            // Add disabled/completed styling
            startBtn.classList.add('from-slate-700', 'to-slate-800', 'opacity-100', 'cursor-pointer'); 
            
            // Interaction: Enable click to view score, but disable game start
            startBtn.onclick = openDailyScoreboard;
            startBtn.disabled = false; 
            
            // Icon: Hide
            if(btnIcon) btnIcon.style.display = 'none';

            // Content: Start Countdown Timer (updates text)
            startDailyCountdown(btnTextSpan, data.daily.finalScore);
            
        } else {
            // --- STATE: ACTIVE ---
            
            // Remove disabled styling
            startBtn.classList.remove('from-slate-700', 'to-slate-800', 'opacity-100', 'cursor-pointer');
            
            // Restore active styling
            startBtn.classList.add('from-yellow-500', 'to-yellow-600', 'hover:from-yellow-400', 'hover:to-yellow-500', 'hover:scale-105', 'active:scale-95');
            
            // Interaction: Enable click
            startBtn.onclick = () => startGame('daily');
            startBtn.disabled = false;
            
            // Icon: Show
            if(btnIcon) btnIcon.style.display = 'block';
            
            // Content: Reset Text
            if(countdownInterval) clearInterval(countdownInterval);
            btnTextSpan.innerHTML = "DAILY CHALLENGE";
        }
    }

    let countdownInterval = null;
    function startDailyCountdown(element, score) {
        if (countdownInterval) clearInterval(countdownInterval);
        
        const updateTimer = () => {
            const now = new Date();
            const tomorrow = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + 1));
            const diff = tomorrow - now;
            
            if (diff <= 0) {
                updateMenuUI(); // Refresh UI when timer hits 0
                return;
            }
            
            const h = Math.floor(diff / (1000 * 60 * 60));
            const m = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            
            const timeStr = `${String(h).padStart(2,'0')}h ${String(m).padStart(2,'0')}m`;
            
            element.innerHTML = `
                <div class="flex flex-col items-center">
                    <div class="text-xs text-slate-400 uppercase tracking-wider mb-1 font-bold">Daily Complete â€¢ Score: <span class="text-white">${score}</span></div>
                    <div class="text-lg font-mono text-slate-200 tracking-wide">NEXT IN ${timeStr}</div>
                </div>
            `;
        };
        
        updateTimer();
        countdownInterval = setInterval(updateTimer, 60000); 
    }

    function openDailyScoreboard() {
        const data = getStoredData();
        if (data.daily) {
            const state = data.daily;
            currentMode = 'daily';

            // 1. Hydrate State (Logic only, no DOM rendering, NO AUDIO)
            elapsedTime = state.elapsedTime || 0;
            hintsUsed = state.hintsUsed || 0;
            currentSolution = state.currentSolution;
            finalScore = state.finalScore || 0;
            isGameWon = state.isComplete || false;
            
            // Determine if it was auto-solved based on score
            isAutoSolving = (finalScore === 0); 

            // Reconstruct Sets
            lockedIndices = new Set(state.lockedIndices);
            failedRows = new Set(state.failedRows);
            failedCols = new Set(state.failedCols);
            processedPatterns = new Set(state.processedPatterns);
            solvedPatterns = new Set(state.solvedPatterns);
            errorPatterns = new Set(state.errorPatterns);
            
            gridState = state.gridState;
            inventory = state.inventory; 

            // 2. Prepare Modal Content
            renderScoreGrid();
            const modal = document.getElementById('modal');
            
            // Restore Message
            if (state.winMessage) {
                document.querySelector('#modal-content p').innerText = state.winMessage;
            } else {
                document.querySelector('#modal-content p').innerText = "Daily Challenge Completed.";
            }
            
            if (isAutoSolving) {
                 document.querySelector('#modal-content h2').innerText = "AUTO-SOLVED";
            } else {
                 document.querySelector('#modal-content h2').innerText = "SOLVED!";
            }

            // Hide "Next Puzzle" button since it's daily
            document.getElementById('playAgainBtn').style.display = 'none';
            
            // 3. Show Modal (Keep Menu/Overlay Visible behind it)
            modal.classList.remove('hidden');
            // Use RAF to ensure transition works after removing hidden
            requestAnimationFrame(() => {
                modal.classList.remove('opacity-0');
            });
            
            // NOTE: We explicitly do NOT hide 'startup-overlay' here.
            // This keeps the menu visible in the background.
        }
    }

    function showMenu(instant = false) {
        // Save current game before quitting
        if (currentSolution.length > 0 && !isAutoSolving) {
            saveGameState();
        }
        
        pauseTimer();
        
        const overlay = document.getElementById('startup-overlay');
        overlay.style.display = 'flex';
        
        if (instant) {
            overlay.classList.remove('opacity-0');
            overlay.style.pointerEvents = 'auto';
        } else {
            // Small delay to allow display:flex to apply before opacity transition
            setTimeout(() => {
                overlay.classList.remove('opacity-0');
                overlay.style.pointerEvents = 'auto';
            }, 10);
        }

        updateMenuUI();
    }

    // --- Utility Functions ---
    
    let seed = 1;

    function hashString(str) {
        let h = 0;
        const s = String(str);
        for (let i = 0; i < s.length; i++) {
            h = s.charCodeAt(i) + ((h << 5) - h);
        }
        return (h >>> 0) || 1; 
    }

    function setSeed(s) {
        seed = hashString(s);
    }

    function seededRandom() {
        const a = 1664525;
        const c = 1013904223;
        seed = (seed * a + c) >>> 0;
        return seed / 0x100000000; 
    }
    
    function getDailySeed() {
        const date = new Date();
        const y = date.getUTCFullYear();
        const m = String(date.getUTCMonth() + 1).padStart(2, '0');
        const d = String(date.getUTCDate()).padStart(2, '0');
        return `${y}${m}${d}`;
    }

    function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        const pad = (num) => String(num).padStart(2, '0');
        return `${pad(minutes)}:${pad(remainingSeconds)}`;
    }

    function startTimer() {
        if (timerInterval) clearInterval(timerInterval);
        startTime = Date.now() - (elapsedTime * 1000); 
        timerInterval = setInterval(() => {
            elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            document.getElementById('timerDisplay').innerText = formatTime(elapsedTime);
        }, 1000);
    }

    function pauseTimer() {
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = null;
    }

    function resetTimer() {
        pauseTimer();
        elapsedTime = 0;
        document.getElementById('timerDisplay').innerText = "00:00";
    }

    // --- Logic ---
    
    function generatePuzzle(customSeed = Math.random()) {
        setSeed(customSeed); 
        const rows = [];
        usedWordsInPuzzle.clear();
        const shuffled = fisherYatesShuffle([...COMMON_WORDS]); 
        if (solveRow(0, rows, shuffled)) return rows.join('').split('');
        return ['TIME','IDEA','MEAL','EARN'].join('').split('');
    }

    function fisherYatesShuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(seededRandom() * (i + 1)); 
            [array[i], array[j]] = [array[j], array[i]]; 
        }
        return array;
    }

    function solveRow(rowIndex, currentRows, wordList) {
        if (rowIndex === 4) {
            const colSet = new Set();
            for (let c = 0; c < 4; c++) {
                let colWord = '';
                for (let r = 0; r < 4; r++) colWord += currentRows[r][c];
                if (!WORD_SET.has(colWord)) return false;
                if (usedWordsInPuzzle.has(colWord)) return false; 
                if(colSet.has(colWord)) return false;
                colSet.add(colWord);
            }
            return true;
        }
        for (let w of wordList) {
            if (usedWordsInPuzzle.has(w)) continue;
            let validPrefix = true;
            for (let c = 0; c < 4; c++) {
                let prefix = "";
                for (let r = 0; r < rowIndex; r++) prefix += currentRows[r][c];
                prefix += w[c];
                if (!PREFIX_SET.has(prefix)) {
                    validPrefix = false;
                    break;
                }
            }
            if (validPrefix) {
                currentRows.push(w);
                usedWordsInPuzzle.add(w);
                if (solveRow(rowIndex + 1, currentRows, wordList)) return true;
                usedWordsInPuzzle.delete(w);
                currentRows.pop();
            }
        }
        return false;
    }

    function playTone(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        switch(type) {
            case 'pickup':
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1); break;
            case 'drop':
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1); break;
            case 'match':
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.linearRampToValueAtTime(880, now + 0.15);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3); break;
            case 'error': 
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.2);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3); break;
            case 'triumph': 
                osc.type = 'square';
                osc.frequency.setValueAtTime(784, now);
                osc.frequency.linearRampToValueAtTime(1244, now + 0.1);
                osc.frequency.linearRampToValueAtTime(1568, now + 0.2);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                osc.start(now); osc.stop(now + 0.4); break;
            case 'win':
                osc.type = 'square';
                osc.frequency.setValueAtTime(523, now);
                osc.frequency.setValueAtTime(659, now + 0.1);
                osc.frequency.setValueAtTime(784, now + 0.2);
                osc.frequency.setValueAtTime(1046, now + 0.3);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                osc.start(now); osc.stop(now + 0.8); break;
        }
    }

    // --- Game Initialization Logic ---

    function startGame(mode, onReady = null) {
        // 1. Fix Audio
        if (audioCtx.state === 'suspended') audioCtx.resume();
        
        // 2. Set Mode
        currentMode = mode;
        
        // 3. Check for stored data
        const data = getStoredData();
        const savedState = data[mode];

        // 4. Update UI Buttons (Disable Reset for Daily)
        const resetBtn = document.getElementById('newGameBtn');
        if (mode === 'daily') {
            resetBtn.classList.add('btn-disabled');
            resetBtn.disabled = true;
        } else {
            resetBtn.classList.remove('btn-disabled');
            resetBtn.disabled = false;
        }

        // 5. Restore or Create Game
        if (savedState && !savedState.isComplete) {
            restoreGame(savedState, true);
            if (onReady) onReady();
        } else {
            // If daily is complete, we shouldn't even be here due to menu logic,
            // but just in case, start fresh or handle normally.
            // For practice modes, start fresh if no save.
            initNewGame(mode, onReady);
        }
        
        // 6. Hide Overlay
        const overlay = document.getElementById('startup-overlay');
        overlay.classList.add('opacity-0');
        overlay.style.pointerEvents = 'none';
        setTimeout(() => { overlay.style.display = 'none'; }, 500);
    }

    function restoreGame(state, startPlaying = true) {
        document.getElementById('status-msg').innerHTML = '<span class="loader"></span>';
        
        // Load simple vars
        elapsedTime = state.elapsedTime || 0;
        hintsUsed = state.hintsUsed || 0;
        currentSolution = state.currentSolution;
        isGameWon = state.isComplete || false;
        finalScore = state.finalScore || 0;
        
        // Reconstruct Sets (JSON converts them to Arrays)
        lockedIndices = new Set(state.lockedIndices);
        failedRows = new Set(state.failedRows);
        failedCols = new Set(state.failedCols);
        processedPatterns = new Set(state.processedPatterns);
        solvedPatterns = new Set(state.solvedPatterns);
        errorPatterns = new Set(state.errorPatterns);
        
        // Restore Grid/Inventory
        gridState = state.gridState;
        inventory = state.inventory;
        
        document.getElementById('timerDisplay').innerText = formatTime(elapsedTime);
        
        // FIX: Always allow pointer events so buttons (like Menu) remain clickable.
        // The modal overlay prevents gameplay interaction when solved.
        document.body.style.pointerEvents = 'auto';

        if (startPlaying) {
            document.getElementById('status-msg').innerText = "SELECT & PLACE";
            render();
            startTimer();
        } else {
            document.getElementById('status-msg').innerText = "SOLVED!";
            render();
            // Do NOT start timer
        }
    }

    function initNewGame(mode, onReady = null) {
        document.getElementById('status-msg').innerHTML = '<span class="loader"></span>';
        resetTimer(); 
        isAutoSolving = false; 
        isGameWon = false;
        finalScore = 0;
        
        // Removed setTimeout - Execute Immediately
        let puzzleSeed = Math.random(); 
        if (mode === 'daily') {
            puzzleSeed = getDailySeed(); 
        }
        
        currentSolution = generatePuzzle(puzzleSeed); 
        setupBoard(puzzleSeed, mode); 
        startTimer(); 
        
        // Save initial state immediately
        saveGameState();
        
        if (onReady) onReady();
    }

    function setupBoard(puzzleSeed, mode) { 
        gridState = Array(16).fill(null);
        lockedIndices.clear();
        selectedState = null;
        inventory = [];
        hintsUsed = 0; 
        isAutoSolving = false; 
        solvedPatterns.clear();
        errorPatterns.clear();
        
        failedRows.clear();
        failedCols.clear();
        processedPatterns.clear();
        
        isGameWon = false; // Ensure flag is reset

        document.getElementById('status-msg').innerText = "SELECT & PLACE";
        document.body.style.pointerEvents = 'auto';

        let keepCount = 5;
        if (mode === 'easy') keepCount = 8;
        if (mode === 'hard') keepCount = 3;

        setSeed(puzzleSeed + 'LAYOUT');
        const indices = Array.from({length: 16}, (_, i) => i);
        for (let i = indices.length - 1; i > 0; i--) {
            const j = Math.floor(seededRandom() * (i + 1));
            [indices[i], indices[j]] = [indices[j], indices[i]];
        }
        for (let i = 0; i < keepCount; i++) {
            const idx = indices[i];
            gridState[idx] = currentSolution[idx];
            lockedIndices.add(idx);
        }
        for (let i = keepCount; i < 16; i++) {
            inventory.push(currentSolution[indices[i]]);
        }
        setSeed(puzzleSeed + 'INV'); 
        inventory.sort(() => seededRandom() - 0.5);

        render();
    }

    // --- Interactions ---

    function render() {
        renderGrid();
        renderInventory();
        checkPatterns();
        if (selectedState) {
            const selector = selectedState.source === 'grid' 
                ? `.cell[data-index="${selectedState.index}"] .tile` 
                : `.tile[data-source="inventory"][data-index="${selectedState.index}"]`;
            const tile = document.querySelector(selector);
            if (tile) tile.classList.add('selected');
        }
    }

    function renderGrid() {
        const container = document.getElementById('game-grid');
        container.innerHTML = '';
        for (let i = 0; i < 16; i++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.index = i;
            cell.onclick = () => handleCellClick(i);
            if (gridState[i] !== null) {
                const tile = createTile(gridState[i], lockedIndices.has(i));
                tile.dataset.source = 'grid';
                tile.dataset.index = i;
                cell.appendChild(tile);
            }
            container.appendChild(cell);
        }
    }

    function renderInventory() {
        const container = document.getElementById('inventory');
        container.innerHTML = '';
        inventory.forEach((char, index) => {
            const slot = document.createElement('div');
            slot.className = 'inventory-slot';
            const tile = createTile(char, false);
            tile.dataset.source = 'inventory';
            tile.dataset.index = index;
            slot.appendChild(tile);
            container.appendChild(slot);
        });
    }

    function createTile(char, isLocked) {
        const div = document.createElement('div');
        div.className = 'tile';
        if (isLocked) div.classList.add('hard-locked');
        div.textContent = char;
        if (!isLocked) div.addEventListener('pointerdown', handlePointerDown);
        return div;
    }

    // ... Drag & Drop Logic ...
    let dragItem = null, dragData = null, startX = 0, startY = 0, isDragging = false;
    let tileWidth = 0;
    let tileHeight = 0;

    function handlePointerDown(e) {
        if (audioCtx.state === 'suspended') audioCtx.resume().catch(e=>{});
        e.preventDefault(); 
        const target = e.currentTarget;
        if (tileWidth === 0) {
            const style = getComputedStyle(target);
            tileWidth = parseFloat(style.width);
            tileHeight = parseFloat(style.height);
        }
        dragData = { char: target.textContent, source: target.dataset.source, index: parseInt(target.dataset.index), originalElement: target };
        startX = e.clientX; startY = e.clientY; isDragging = false;
        document.addEventListener('pointermove', handlePointerMove);
        document.addEventListener('pointerup', handlePointerUp);
    }

    function handlePointerMove(e) {
        e.preventDefault();
        if (Math.hypot(e.clientX - startX, e.clientY - startY) > 10 && !isDragging) startDrag(e);
        if (isDragging && dragItem) {
            const halfScaledWidth = (tileWidth * 1.1) / 2;
            const halfScaledHeight = (tileHeight * 1.1) / 2;
            dragItem.style.left = (e.clientX - halfScaledWidth) + 'px';
            dragItem.style.top = (e.clientY - halfScaledHeight) + 'px';
            highlightDropTarget(e.clientX, e.clientY);
        }
    }

    function startDrag(e) {
        isDragging = true;
        if (selectedState) { selectedState = null; document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected')); }
        dragItem = dragData.originalElement.cloneNode(true);
        dragItem.classList.add('dragging'); dragItem.classList.remove('selected');
        dragItem.style.transform = 'scale(1.1)'; 
        const halfScaledWidth = (tileWidth * 1.1) / 2;
        const halfScaledHeight = (tileHeight * 1.1) / 2;
        dragItem.style.left = (e.clientX - halfScaledWidth) + 'px';
        dragItem.style.top = (e.clientY - halfScaledHeight) + 'px';
        document.body.appendChild(dragItem);
        dragData.originalElement.style.opacity = '0';
        playTone('pickup');
    }

    function handlePointerUp(e) {
        document.removeEventListener('pointermove', handlePointerMove);
        document.removeEventListener('pointerup', handlePointerUp);
        document.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
        if (dragData && dragData.originalElement) dragData.originalElement.style.opacity = '1';
        if (!isDragging) handleClick(); else handleDrop(e);
        if (dragItem) dragItem.remove();
        dragItem = null; dragData = null; isDragging = false;
    }

    function handleClick() {
        const clickedTile = { index: dragData.index, source: dragData.source, char: dragData.char };
        if (selectedState && selectedState.index === clickedTile.index && selectedState.source === clickedTile.source) {
            selectedState = null; playTone('pickup'); render(); return;
        }
        if (!selectedState) {
            selectedState = clickedTile; playTone('pickup'); render(); return;
        }
        if (selectedState.source === 'inventory' && clickedTile.source === 'inventory') {
            selectedState = clickedTile; playTone('pickup'); render(); return;
        }
        performMove(selectedState, clickedTile);
        selectedState = null;
    }

    function handleCellClick(targetIndex) {
        if (!selectedState) return;
        const target = { index: targetIndex, source: 'grid', char: gridState[targetIndex] };
        performMove(selectedState, target);
        selectedState = null;
    }

    function performMove(from, to) {
        let moveMade = false;
        const isPlacement = (from.source === 'inventory' && to.source === 'grid');
        if (from.source === 'grid' && to.source === 'grid') {
            const temp = gridState[to.index]; gridState[to.index] = gridState[from.index]; gridState[from.index] = temp; moveMade = true;
        } else if (isPlacement) {
            const char = inventory[from.index]; const targetChar = gridState[to.index];
            inventory.splice(from.index, 1);
            if (targetChar) inventory.push(targetChar);
            gridState[to.index] = char; moveMade = true;
        } else if (from.source === 'grid' && to.source === 'inventory') {
            const gridChar = gridState[from.index]; const invChar = inventory[to.index];
            gridState[from.index] = invChar; inventory[to.index] = gridChar; moveMade = true;
        } else if (from.source === 'inventory' && to.source === 'inventory') {
            const temp = inventory[to.index]; inventory[to.index] = inventory[from.index]; inventory[from.index] = temp; moveMade = true;
        }
        if (moveMade) { 
            playTone('drop'); 
            render(); 
            // Save on every valid move
            saveGameState();
        }
    }

    function handleDrop(e) {
        dragItem.style.display = 'none';
        const elemBelow = document.elementFromPoint(e.clientX, e.clientY);
        const cell = elemBelow ? elemBelow.closest('.cell') : null;
        if (cell) {
            const targetIndex = parseInt(cell.dataset.index);
            if (lockedIndices.has(targetIndex)) { cancelDrag(); return; }
            const target = { index: targetIndex, source: 'grid', char: gridState[targetIndex] };
            const from = { index: dragData.index, source: dragData.source, char: dragData.char };
            performMove(from, target);
        } else if (dragData.source === 'grid') {
            gridState[dragData.index] = null; 
            inventory.push(dragData.char); 
            playTone('drop'); 
            render();
            saveGameState();
        } else { 
            cancelDrag(); 
        }
    }

    function cancelDrag() { dragData.originalElement.style.opacity = '1'; }

    function highlightDropTarget(x, y) {
        document.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
        dragItem.style.display = 'none';
        const el = document.elementFromPoint(x, y);
        dragItem.style.display = 'block';
        const cell = el?.closest('.cell');
        if (cell && !lockedIndices.has(parseInt(cell.dataset.index))) cell.classList.add('highlight');
    }

    function checkPatterns() {
        document.querySelectorAll('.word-glow').forEach(el => el.classList.remove('word-glow'));
        document.querySelectorAll('.triumph').forEach(el => el.classList.remove('triumph'));
        
        let justSolved = false;
        let triumphIndices = new Set(); 

        const processLine = (indices, type, index, solutionWord) => {
            let w = '';
            indices.forEach(idx => w += (gridState[idx] || ' '));
            const patternKey = `${type}${index}:${w}`; 
            const id = `${type}${index}`;

            if (w.length === 4 && !w.includes(' ')) {
                if (processedPatterns.has(patternKey)) {
                    if (w === solutionWord) highlightWord(indices);
                    return;
                }
                processedPatterns.add(patternKey);
                if (w === solutionWord) {
                    highlightWord(indices);
                    let hasFailed = (type === 'R') ? failedRows.has(index) : failedCols.has(index);
                    if (!solvedPatterns.has(id)) {
                        justSolved = true;
                        if (!hasFailed) indices.forEach(idx => triumphIndices.add(idx));
                    }
                    solvedPatterns.add(id);
                } else {
                    if (type === 'R') failedRows.add(index); else failedCols.add(index);
                    highlightWordError(indices);
                    playTone('error');
                    if (solvedPatterns.has(id)) solvedPatterns.delete(id);
                }
            } else {
                if (solvedPatterns.has(id)) solvedPatterns.delete(id);
            }
        };

        for(let r=0; r<4; r++) {
            const solutionWord = currentSolution.slice(r*4, r*4+4).join('');
            const idxs = [r*4, r*4+1, r*4+2, r*4+3];
            processLine(idxs, 'R', r, solutionWord);
        }
        for(let c=0; c<4; c++) {
            let solutionWord = '';
            let idxs = [];
            for(let r=0; r<4; r++) {
                solutionWord += currentSolution[r*4 + c];
                idxs.push(r*4 + c);
            }
            processLine(idxs, 'C', c, solutionWord);
        }

        if (triumphIndices.size > 0) {
            playTone('triumph');
            triumphIndices.forEach(idx => {
                const cell = document.querySelector(`.cell[data-index="${idx}"]`);
                if (cell && cell.querySelector('.tile')) cell.querySelector('.tile').classList.add('triumph');
            });
        } else if (justSolved) {
             playTone('match'); 
        }
        checkWin(true);
    }

    function highlightWord(indices) {
        indices.forEach(idx => {
            const cell = document.querySelector(`.cell[data-index="${idx}"]`);
            if (cell && cell.querySelector('.tile')) cell.querySelector('.tile').classList.add('word-glow');
        });
    }

    function highlightWordError(indices) {
        indices.forEach(idx => {
            const cell = document.querySelector(`.cell[data-index="${idx}"]`);
            if (cell && cell.querySelector('.tile')) cell.querySelector('.tile').classList.add('word-error');
        });
    }

    function checkWin(playAudio) {
        const isWin = gridState.every((char, i) => char === currentSolution[i]);
        if (isAutoSolving) return; 

        if (isWin) {
            pauseTimer();
            if (playAudio) playTone('win');
            
            const totalScore = renderScoreGrid(true); // Calculate and render
            
            // Update Global State for persistence
            isGameWon = true;
            finalScore = totalScore;
            
            let winMessage = "Perfect! You solved the grid yourself!";
             if (hintsUsed > 0) {
                 winMessage = `Victory in ${formatTime(elapsedTime)}! You used ${hintsUsed} hint(s).`;
             } else {
                 winMessage = `Flawless Victory in ${formatTime(elapsedTime)}!`;
             }
             
             document.querySelector('#modal-content h2').innerText = "SOLVED!";
             document.querySelector('#modal-content p').innerText = winMessage;
             
             // Hide next puzzle if daily
             const nextBtn = document.getElementById('playAgainBtn');
             if (currentMode === 'daily') {
                 nextBtn.style.display = 'none';
                 
                 // Manually update daily storage to include winMessage
                 const data = getStoredData();
                 if (!data.daily) data.daily = {};
                 data.daily.isComplete = true;
                 data.daily.finalScore = totalScore;
                 data.daily.seed = getDailySeed();
                 data.daily.winMessage = winMessage; // SAVE MESSAGE
                 
                 // Also save component state
                 data.daily.gridState = gridState;
                 data.daily.elapsedTime = elapsedTime;
                 data.daily.hintsUsed = hintsUsed;
                 data.daily.inventory = inventory;
                 data.daily.lockedIndices = [...lockedIndices];
                 
                 localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
                 
             } else {
                 nextBtn.style.display = 'block';
                 // For practice modes, save the game state as "Complete" immediately
                 // so the menu knows to start a new one next time
                 saveGameState();
             }

             const modal = document.getElementById('modal');
             modal.classList.remove('hidden');
             void modal.offsetWidth;
             modal.classList.remove('opacity-0');
        }
    }

    function renderScoreGrid(returnScore = false) {
        const container = document.getElementById('modal-score-container');
        const legendContainer = document.getElementById('score-legend');
        const scoreDisplay = document.getElementById('final-score');
        container.innerHTML = '';
        legendContainer.innerHTML = '';
        
        const POINTS = { PERFECT: 4, SEMI: 2, CORRECT: 1, LOCKED: 0 };
        let tileScore = 0;

        if (isAutoSolving) {
             for (let i = 0; i < 16; i++) {
                const cell = document.createElement('div');
                cell.className = 'score-cell locked';
                container.appendChild(cell);
             }
             scoreDisplay.innerText = "0";
             legendContainer.innerHTML = `<span class="text-slate-500 italic">Auto-solved</span>`;
             return 0;
        }

        for (let i = 0; i < 16; i++) {
            const cell = document.createElement('div');
            cell.className = 'score-cell';
            if (lockedIndices.has(i)) {
                cell.classList.add('locked');
                tileScore += POINTS.LOCKED;
            } else {
                const r = Math.floor(i / 4);
                const c = i % 4;
                const rowIsFirstTry = !failedRows.has(r);
                const colIsFirstTry = !failedCols.has(c);
                if (rowIsFirstTry && colIsFirstTry) {
                    cell.classList.add('perfect'); tileScore += POINTS.PERFECT;
                } else if (rowIsFirstTry || colIsFirstTry) {
                    cell.classList.add('semi-perfect'); tileScore += POINTS.SEMI;
                } else {
                    cell.classList.add('correct'); tileScore += POINTS.CORRECT;
                }
            }
            container.appendChild(cell);
        }

        const timeMultiplier = Math.floor(1000 / Math.max(elapsedTime, 30));
        const totalScore = tileScore * timeMultiplier;
        
        scoreDisplay.innerText = totalScore.toLocaleString();

        const legendItems = [
            { label: "Perfect", class: "perfect", color: "#facc15" },
            { label: "Good", class: "semi-perfect", color: "#3b82f6" },
            { label: "Solved", class: "correct", color: "#94a3b8" },
            { label: "Locked", class: "locked", color: "#020617", border: "1px solid #334155" }
        ];

        legendItems.forEach(item => {
            const keyItem = document.createElement('div');
            keyItem.className = 'score-key-item';
            const dot = document.createElement('div');
            dot.className = 'key-dot';
            dot.style.backgroundColor = item.color;
            if (item.border) dot.style.border = item.border;
            if (item.class === 'perfect') dot.style.boxShadow = "0 0 5px rgba(250, 204, 21, 0.5)";
            const label = document.createElement('span');
            label.innerText = item.label;
            keyItem.appendChild(dot);
            keyItem.appendChild(label);
            legendContainer.appendChild(keyItem);
        });
        
        return totalScore;
    }

    function giveHint() {
        const wrongIndices = [];
        for(let i=0; i<16; i++) {
            if (lockedIndices.has(i)) continue;
            if (gridState[i] !== currentSolution[i]) wrongIndices.push(i);
        }
        if (wrongIndices.length === 0) return;

        const targetIdx = wrongIndices[Math.floor(Math.random() * wrongIndices.length)];
        const correctChar = currentSolution[targetIdx];
        
        const r = Math.floor(targetIdx / 4);
        const c = targetIdx % 4;
        failedRows.add(r);
        failedCols.add(c);

        if (gridState[targetIdx]) inventory.push(gridState[targetIdx]);
        const invIdx = inventory.indexOf(correctChar);
        if (invIdx > -1) inventory.splice(invIdx, 1);
        else {
            const otherIdx = gridState.findIndex((c, i) => c === correctChar && !lockedIndices.has(i) && i !== targetIdx);
            if (otherIdx > -1) gridState[otherIdx] = null;
        }
        gridState[targetIdx] = correctChar;
        lockedIndices.add(targetIdx);
        
        hintsUsed++; 
        let statusMsg;
        if (hintsUsed > 2) {
            statusMsg = SARCASTIC_MESSAGES.HINT_FAIL[Math.floor(Math.random() * SARCASTIC_MESSAGES.HINT_FAIL.length)];
        } else {
            statusMsg = SARCASTIC_MESSAGES.HINT[Math.floor(Math.random() * SARCASTIC_MESSAGES.HINT.length)];
        }
        document.getElementById('status-msg').innerText = statusMsg;
        playTone('match');
        render();
        saveGameState();
    }

    async function solve() {
        pauseTimer(); 
        isAutoSolving = true; 
        const solveTime = formatTime(elapsedTime);
        const sarcasticMsgTemplate = SARCASTIC_MESSAGES.SOLVE[Math.floor(Math.random() * SARCASTIC_MESSAGES.SOLVE.length)];
        document.getElementById('status-msg').innerText = sarcasticMsgTemplate;
        document.body.style.pointerEvents = 'none';
        selectedState = null; render();

        for (let i = 0; i < 16; i++) {
            const targetChar = currentSolution[i];
            if (gridState[i] === targetChar) continue;
            let foundInInventory = inventory.indexOf(targetChar);
            let foundInGrid = -1;
            if (foundInInventory !== -1) {
                const wrongChar = gridState[i];
                inventory.splice(foundInInventory, 1);
                if (wrongChar) inventory.push(wrongChar);
                gridState[i] = targetChar;
            } else {
                for(let k=0; k<16; k++) {
                    if (k === i) continue;
                    if (gridState[k] === targetChar && !lockedIndices.has(k)) {
                        foundInGrid = k; break;
                    }
                }
                if (foundInGrid !== -1) {
                    const wrongChar = gridState[i];
                    gridState[i] = gridState[foundInGrid];
                    gridState[foundInGrid] = wrongChar;
                } else {
                    gridState[i] = targetChar;
                }
            }
            playTone('drop');
            render();
            await new Promise(r => setTimeout(r, 150));
        }
        
        const solveMessage = `I solved it in ${solveTime}. It seems one of us is a grid master!`;
        document.querySelector('#modal-content h2').innerText = "AUTO-SOLVED";
        document.querySelector('#modal-content p').innerText = solveMessage;
        lockedIndices = new Set([...Array(16).keys()]);
        checkPatterns();
        playTone('win'); 
        renderScoreGrid();
        document.body.style.pointerEvents = 'auto';
        
        // Reset save for practice modes to avoid stuck solved state
        if (currentMode !== 'daily') {
            clearModeState(currentMode);
            // Ensure Next Puzzle button is visible for non-daily
            document.getElementById('playAgainBtn').style.display = 'block';
        } else {
            // Hide Next Puzzle button for daily
            document.getElementById('playAgainBtn').style.display = 'none';
            
            // Update global state for persistence
            isGameWon = true;
            finalScore = 0;
            
            const data = getStoredData();
            if (!data.daily) data.daily = {};
            data.daily.isComplete = true;
            data.daily.finalScore = 0;
            data.daily.seed = getDailySeed(); 
            data.daily.winMessage = solveMessage; // SAVE MESSAGE
            
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        }

        const modal = document.getElementById('modal');
        modal.classList.remove('hidden');
        void modal.offsetWidth;
        modal.classList.remove('opacity-0');
        
        isAutoSolving = false; 
        document.getElementById('status-msg').innerText = "SOLVED!";
    }

    document.getElementById('newGameBtn').addEventListener('click', () => { 
        playTone('pickup'); 
        // Reset Logic
        clearModeState(currentMode);
        initNewGame(currentMode);
    });
    
    document.getElementById('menuBtn').addEventListener('click', () => {
        playTone('pickup');
        showMenu();
    });

    document.getElementById('hintBtn').addEventListener('click', giveHint);
    document.getElementById('solveBtn').addEventListener('click', solve);
    
    document.getElementById('playAgainBtn').addEventListener('click', () => {
        // Instant action: Hide modal immediately (but wait for new game render)
        document.querySelector('#modal-content h2').innerText = "SOLVED!";
        
        clearModeState(currentMode);
        initNewGame(currentMode, () => {
            // Only hide modal after new board is ready to prevent flash
            const modal = document.getElementById('modal');
            modal.classList.add('hidden');
            modal.classList.add('opacity-0');
        });
    });

    document.getElementById('modalMenuBtn').addEventListener('click', () => {
        const modal = document.getElementById('modal');
        modal.classList.add('hidden');
        modal.classList.add('opacity-0');
        
        const overlay = document.getElementById('startup-overlay');
        const isMenuVisible = window.getComputedStyle(overlay).display !== 'none';
        
        if (!isMenuVisible) {
            showMenu(true); // Pass instant=true
        } else {
            updateMenuUI(); 
        }
    });

    // Global click listener for Background Deselect / Return to Inventory
    document.addEventListener('click', (e) => {
        if (!selectedState) return;
        if (e.target.closest('.tile') || e.target.closest('.cell') || e.target.closest('button') || e.target.closest('select')) return;

        if (selectedState.source === 'grid') {
            const idx = selectedState.index;
            const char = selectedState.char;
            if (lockedIndices.has(idx)) { selectedState = null; render(); return; }
            gridState[idx] = null;
            inventory.push(char);
            playTone('drop');
            selectedState = null;
            render();
            saveGameState();
        } else {
            selectedState = null;
            playTone('pickup');
            render();
        }
    });

    lucide.createIcons();
    // Initial Menu Update
    updateMenuUI();
</script>
</body>
</html>
